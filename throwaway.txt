void setMomentumEquationMatrix(Data2D& data, SpMat& momMatrix, Vector& momVector, int nVelocities, int step) {
    for (int i = 0; i < nVelocities; i++) {
        Face2D* curFace = &data.faces[i];
        if (curFace->bType_u == DIRICHLET || curFace->bType_u == SOLID) {
            momMatrix.insert(i, i) = 1.0;
            if (nVelocities == data.nhorizontalFaces) {
                momVector(i) = curFace->v[step - 1];
            } else {
                momVector(i) = curFace->u[step - 1];
            }
        } else if (curFace->bType_u == INNERCELL) {
            momVector(i) = curFace->b[step];
            if (i > 0) {
                momMatrix.insert(i, i - 1) = curFace->a_w[step];
            }
            if (i < nVelocities - 1) {
                momMatrix.insert(i, i + 1) = curFace->a_e[step];
            }
            momMatrix.insert(i, i) = -curFace->a_p_tilde[step];
            if (i >= data.dimX) {
                momMatrix.insert(i, i - data.dimX) = curFace->a_n[step];
            }
            if (i < nVelocities - data.dimX) {
                momMatrix.insert(i, i + data.dimX) = curFace->a_s[step];
            }
        } else if (curFace->bType_u == NEUMANN) {
            momMatrix.insert(i, i) = -1.0;
            if (i < data.nhorizontalFaces) {
                if(curFace->neighCells[UP] == nullptr || curFace->neighCells[UP]->bType_sc == SOLID)                                                     //TOP BOUNDARY (HORIZONTAL)
                {
                    if (i >= data.dimX) {
                        momMatrix.insert(i, i - data.dimX) = 1.0;
                    }
                }
                else if (curFace->neighCells[DOWN] == nullptr || curFace->neighCells[DOWN]->bType_sc == SOLID)                                           //BOTTOM BOUNDARY (HORIZONTAL) 
                {
                    if (i < nVelocities - data.dimX) {
                        momMatrix.insert(i, i + data.dimX) = 1.0;
                    }

                }
                else if (curFace->neighCells[UP]->neighCells[WEST] == nullptr || curFace->neighCells[UP]->neighCells[WEST]->bType_sc == SOLID || curFace->neighCells[UP]->neighCells[EAST] == nullptr || curFace->neighCells[UP]->neighCells[EAST]->bType_sc == SOLID)      	 //LEFT and RIGHT BOUNDARY (HORIZONTAL)
                {
                    if (i >= data.dimX) {
                        momMatrix.insert(i, i - data.dimX) = 1.0;
                    }
                }
            }
            else {
                if(curFace->neighCells[LEFT] == nullptr || curFace->neighCells[LEFT]->bType_sc == SOLID)                                                 //LEFT BOUNDARY (VERTICAL) 
                {
                    if (i < nVelocities - 1) {
                        momMatrix.insert(i, i + 1) = 1.0;
                    }
                }
                else if (curFace->neighCells[RIGHT] == nullptr || curFace->neighCells[RIGHT]->bType_sc == SOLID)                                         //RIGHT BOUNDARY (VERTICAL)
                {
                    momMatrix.insert(i, i - 1) = 1.0;
                }
                else if (curFace->neighCells[LEFT]->neighCells[SOUTH] == nullptr || curFace->neighCells[LEFT]->neighCells[SOUTH]->bType_sc == SOLID || curFace->neighCells[RIGHT]->neighCells[SOUTH] == nullptr || curFace->neighCells[RIGHT]->neighCells[SOUTH]->bType_sc == SOLID)     //BOTTOM and TOP BOUNDARY (VERTICAL)
                {
                    if (i < nVelocities - 1) {
                        momMatrix.insert(i, i + 1) = 1.0;
                    }
                }
            }
        }
    }
}

void predictVelocityField(Data2D& data) {
    for (int i = 0; i < data.nFaces; i++) {
        Face2D *curFace = &data.faces[i];
        if (curFace->bType_u == INNERCELL) {                        
            if (i < data.nhorizontalFaces) {
                computeVelocityCoeff_y(data, i, INTERMEDIATE_1);
            }
            else if (i >= data.nhorizontalFaces) {
                computeVelocityCoeff_x(data, i, INTERMEDIATE_1);
            }
        }
    }
    SpMat uMatrix(data.nverticalFaces, data.nverticalFaces);
    SpMat vMatrix(data.nhorizontalFaces, data.nhorizontalFaces);
    Vector uVector(data.nverticalFaces);
    Vector vVector(data.nhorizontalFaces);
    uMatrix.setZero();	
    vMatrix.setZero();
    uVector.setZero();
    vVector.setZero();
    setMomentumEquationMatrix(data, uMatrix, uVector, data.nverticalFaces, INTERMEDIATE_1);
    setMomentumEquationMatrix(data, vMatrix, vVector, data.nhorizontalFaces, INTERMEDIATE_1);

    // if (data.timeStep == 49 || data.timeStep == 1){
    //     std::cout << "uMatrix: " << uMatrix << std::endl;
    //     std::cout << "vMatrix: " << vMatrix << std::endl;
    // }

    Eigen::BiCGSTAB<SpMat> solver;
    solver.compute(uMatrix);
    Vector uSolution = solver.solve(uVector);
    solver.compute(vMatrix);
    Vector vSolution = solver.solve(vVector);

    for (int i = 0; i < data.nFaces; i++) {
        Face2D *curFace = &data.faces[i];
        if (i < data.nhorizontalFaces) {
            curFace->v[INTERMEDIATE_1] = vSolution(i);
            // std::cout << "Face " << i << ": v = " << curFace->v[INTERMEDIATE_1] << std::endl;
        }
        else if (i >= data.nhorizontalFaces) {
            curFace->u[INTERMEDIATE_1] = uSolution(i - data.nhorizontalFaces);
            // std::cout << "Face " << i << ": u = " << curFace->u[INTERMEDIATE_1] << std::endl;
        }
    }
}

void solvePressureEquation(Data2D& data, int step) {
    for (int i = 0; i < data.nCells; i++) {
        Cell2D *curCell = &data.cells[i];
        if (curCell->bType_p == INNERCELL) {
            computePressureCoeff(data, i, step);
        }
    }
    for (int i = 0; i < data.nCells; i++) {
        Cell2D *curCell = &data.cells[i];
        if (curCell->bType_p == INNERCELL) {
            curCell->p[step] = (1/curCell->a_p[step]) * (curCell->b[step] + curCell->a_w[step] * curCell->neighCells[WEST]->p[step -1] + curCell->a_e[step] * curCell->neighCells[EAST]->p[step - 1] + curCell->a_n[step] * curCell->neighCells[NORTH]->p[step - 1] + curCell->a_s[step] * curCell->neighCells[SOUTH]->p[step - 1]);
        } else if (curCell->bType_p == DIRICHLET || curCell->bType_p == SOLID) {
            curCell->p[step] = curCell->p[INITIAL];
        } 
    }
    for (int i = 0; i < data.nCells; i++) {
        Cell2D *curCell = &data.cells[i];
        if (curCell->bType_p == NEUMANN) {
            if (curCell->neighCells[EAST] == nullptr || curCell->neighCells[EAST]->bType_sc == SOLID) {
                curCell->p[step] = curCell->neighCells[WEST]->p[step];
            }
            if (curCell->neighCells[WEST] == nullptr || curCell->neighCells[WEST]->bType_sc == SOLID) {
                curCell->p[step] = curCell->neighCells[EAST]->p[step];
            }
            if (curCell->neighCells[NORTH] == nullptr || curCell->neighCells[NORTH]->bType_sc == SOLID) {
                curCell->p[step] = curCell->neighCells[SOUTH]->p[step];
            }
            if (curCell->neighCells[SOUTH] == nullptr || curCell->neighCells[SOUTH]->bType_sc == SOLID) {
                curCell->p[step] = curCell->neighCells[NORTH]->p[step];
            }
        }
    }

}

void setMomentumEquationMatrix(Data2D& data, SpMat& momMatrix, Vector& momVector, int nVelocities, int step, bool isU) {
    for (int i = 0; i <= nVelocities; i++) {
        Face2D* curFace = &data.faces[i];
        if (curFace->bType_u == DIRICHLET || curFace->bType_u == SOLID) {
            momMatrix.insert(i, i) = 1.0;
            if (isU) {
                momVector(i) = curFace->u[step - 1];
            } else {
                momVector(i) = curFace->v[step - 1];
            }
        } else if (curFace->bType_u == INNERCELL) {
            momVector(i) = curFace->b[step];
            if (isU) {
                momMatrix.insert(i, i) = -curFace->a_p_tilde[step];
                if (i > 0) { 
                    momMatrix.insert(i, i - 1) = curFace->a_w[step];
                }
                if (i < nVelocities - 1) {
                    momMatrix.insert(i, i + 1) = curFace->a_e[step];
                }
                if (curFace->points[UP]->faces[NORTH]->id > 0) {
                    int j = curFace->id - curFace->points[UP]->faces[NORTH]->id; 
                    momMatrix.insert(i, j) = curFace->a_n[step];
                }
                if (curFace->points[DOWN]->faces[SOUTH]->id < nVelocities) {
                    int j = curFace->id + curFace->points[DOWN]->faces[SOUTH]->id;
                    momMatrix.insert(i, j) = curFace->a_s[step];
                }
            } else {
                momMatrix.insert(i, i) = -curFace->a_p_tilde[step];
                if (i > 0) {
                    momMatrix.insert(i, i - 1) = curFace->a_w[step];
                }
                if (i < nVelocities - 1) {
                    momMatrix.insert(i, i + 1) = curFace->a_e[step];
                }
                if (curFace->neighCells[UP]->faces[NORTH]->id > 0) {
                    int j = i - curFace->neighCells[UP]->faces[NORTH]->id;
                    momMatrix.insert(i, j) = curFace->a_n[step];
                }
                if (curFace->neighCells[DOWN]->faces[SOUTH]->id < nVelocities) {
                    int j = i + curFace->neighCells[DOWN]->faces[SOUTH]->id;
                    momMatrix.insert(i, j) = curFace->a_s[step];
                }
            }
        } else if (curFace->bType_u == NEUMANN) {
            momMatrix.insert(i, i) = -1.0;
            if (i < data.nhorizontalFaces) {
                if(curFace->neighCells[UP] == nullptr || curFace->neighCells[UP]->bType_sc == SOLID)                                                     //TOP BOUNDARY (HORIZONTAL)
                {
                    // if (i >= data.dimX) {
                    //     momMatrix.insert(i, i - data.dimX) = 1.0;
                    // }
                    momVector(i) = curFace->neighCells[DOWN]->faces[SOUTH]->v[step - 1];
                }
                else if (curFace->neighCells[DOWN] == nullptr || curFace->neighCells[DOWN]->bType_sc == SOLID)                                           //BOTTOM BOUNDARY (HORIZONTAL) 
                {
                    // if (i < nVelocities - data.dimX) {
                    //     momMatrix.insert(i, i + data.dimX) = 1.0;
                    // }
                    momVector(i) = curFace->neighCells[UP]->faces[NORTH]->v[step - 1];
                }
                else if (curFace->neighCells[UP]->neighCells[WEST] == nullptr || curFace->neighCells[UP]->neighCells[WEST]->bType_sc == SOLID || curFace->neighCells[UP]->neighCells[EAST] == nullptr || curFace->neighCells[UP]->neighCells[EAST]->bType_sc == SOLID)      	 //LEFT and RIGHT BOUNDARY (HORIZONTAL)
                {
                    // if (i >= data.dimX) {
                    //     momMatrix.insert(i, i - data.dimX) = 1.0;
                    // }
                    momVector(i) = data.faces[curFace->id + 1].v[step - 1];
                }
            }
            else {
                if(curFace->neighCells[LEFT] == nullptr || curFace->neighCells[LEFT]->bType_sc == SOLID)                                                 //LEFT BOUNDARY (VERTICAL) 
                {
                    // if (i < nVelocities - 1) {
                    //     momMatrix.insert(i, i + 1) = 1.0;
                    // }
                    momVector(i) = curFace->neighCells[RIGHT]->faces[EAST]->u[step - 1];
                }
                else if (curFace->neighCells[RIGHT] == nullptr || curFace->neighCells[RIGHT]->bType_sc == SOLID)                                         //RIGHT BOUNDARY (VERTICAL)
                {
                    // momMatrix.insert(i, i - 1) = 1.0;
                    momVector(i) = curFace->neighCells[LEFT]->faces[WEST]->u[step - 1];
                }
                else if (curFace->neighCells[LEFT]->neighCells[SOUTH] == nullptr || curFace->neighCells[LEFT]->neighCells[SOUTH]->bType_sc == SOLID || curFace->neighCells[RIGHT]->neighCells[SOUTH] == nullptr || curFace->neighCells[RIGHT]->neighCells[SOUTH]->bType_sc == SOLID)     //BOTTOM and TOP BOUNDARY (VERTICAL)
                {
                    // if (i < nVelocities - 1) {
                    //     momMatrix.insert(i, i + 1) = 1.0;
                    // }
                    momVector(i) = curFace->points[UP]->faces[NORTH]->u[step - 1];
                }
            }
        }
    }
}


void correctPressureEquation(Data2D& data) {
    for (int i = 0; i < data.nCells; i++) {
        Cell2D *curCell = &data.cells[i];
        if (curCell->bType_p == INNERCELL) {
            computePressureCoeff(data, i, INTERMEDIATE_1);
        }
    }
    for (int i = 0; i < data.nCells; i++) {
        Cell2D *curCell = &data.cells[i];
        if (curCell->bType_p == INNERCELL) {
            curCell->p[INTERMEDIATE_1] = (1/curCell->a_p[INTERMEDIATE_1]) * (curCell->b[INTERMEDIATE_1] + curCell->a_w[INTERMEDIATE_1] * curCell->neighCells[WEST]->p[INITIAL] + curCell->a_e[INTERMEDIATE_1] * curCell->neighCells[EAST]->p[INITIAL] + curCell->a_n[INTERMEDIATE_1] * curCell->neighCells[NORTH]->p[INITIAL] + curCell->a_s[INTERMEDIATE_1] * curCell->neighCells[SOUTH]->p[INITIAL]);
        } else if (curCell->bType_p == DIRICHLET || curCell->bType_p == SOLID) {
            curCell->p[INTERMEDIATE_1] = curCell->p[INITIAL];
        } 
    }
    for (int i = 0; i < data.nCells; i++) {
        Cell2D *curCell = &data.cells[i];
        if (curCell->bType_p == NEUMANN) {
            if (curCell->neighCells[EAST] == nullptr || curCell->neighCells[EAST]->bType_sc == SOLID) {
                curCell->p[INTERMEDIATE_1] = curCell->neighCells[WEST]->p[INTERMEDIATE_1];
            }
            if (curCell->neighCells[WEST] == nullptr || curCell->neighCells[WEST]->bType_sc == SOLID) {
                curCell->p[INTERMEDIATE_1] = curCell->neighCells[EAST]->p[INTERMEDIATE_1];
            }
            if (curCell->neighCells[NORTH] == nullptr || curCell->neighCells[NORTH]->bType_sc == SOLID) {
                curCell->p[INTERMEDIATE_1] = curCell->neighCells[SOUTH]->p[INTERMEDIATE_1];
            }
            if (curCell->neighCells[SOUTH] == nullptr || curCell->neighCells[SOUTH]->bType_sc == SOLID) {
                curCell->p[INTERMEDIATE_1] = curCell->neighCells[NORTH]->p[INTERMEDIATE_1];
            }
        }
    }
}